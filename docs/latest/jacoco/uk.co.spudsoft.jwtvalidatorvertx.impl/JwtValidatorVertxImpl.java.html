<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>JwtValidatorVertxImpl.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JWT Validator - Vertx</a> &gt; <a href="index.source.html" class="el_package">uk.co.spudsoft.jwtvalidatorvertx.impl</a> &gt; <span class="el_source">JwtValidatorVertxImpl.java</span></div><h1>JwtValidatorVertxImpl.java</h1><pre class="source lang-java linenums">package uk.co.spudsoft.jwtvalidatorvertx.impl;

import com.google.common.base.Strings;
import com.google.common.collect.ImmutableSet;
import io.vertx.core.Future;
import io.vertx.ext.auth.impl.jose.JWK;
import io.vertx.ext.auth.impl.jose.JWS;
import java.nio.charset.StandardCharsets;
import java.security.NoSuchAlgorithmException;
import java.time.Duration;
import java.time.Instant;
import java.time.LocalDateTime;
import java.time.ZoneOffset;
import java.util.Base64;
import java.util.List;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.HashSet;
import static java.util.Objects.requireNonNull;
import java.util.Set;
import uk.co.spudsoft.jwtvalidatorvertx.IssuerAcceptabilityHandler;
import uk.co.spudsoft.jwtvalidatorvertx.JsonWebKeySetHandler;
import uk.co.spudsoft.jwtvalidatorvertx.Jwt;
import uk.co.spudsoft.jwtvalidatorvertx.JwtValidator;

/**
 * Token validation for vertx - implementation of {@link uk.co.spudsoft.jwtvalidatorvertx.JwtValidator}.
 * @author Jim Talbut
 */
public class JwtValidatorVertxImpl implements JwtValidator {

  @SuppressWarnings(&quot;constantname&quot;)
<span class="fc" id="L34">  private static final Logger logger = LoggerFactory.getLogger(JwtValidatorVertxImpl.class);</span>

<span class="fc" id="L36">  private static final Base64.Decoder B64DECODER = Base64.getUrlDecoder();</span>
  
<span class="fc" id="L38">  private static final Set&lt;String&gt; DEFAULT_PERMITTED_ALGS = ImmutableSet.of(</span>
          JWS.EdDSA

          , JWS.ES256
          , JWS.ES384
          , JWS.ES512

          , JWS.PS256
          , JWS.PS384
          , JWS.PS512

          , JWS.ES256K

          , JWS.RS256
          , JWS.RS384
          , JWS.RS512
  );
  
  private Set&lt;String&gt; permittedAlgs;
  
<span class="fc" id="L58">  private boolean requireExp = true;</span>
<span class="fc" id="L59">  private boolean requireNbf = true;</span>
  
<span class="fc" id="L61">  private long timeLeewayMilliseconds = 0;</span>
<span class="fc" id="L62">  private long minimumKeyCacheLifetime = 0;</span>
  
  private final JsonWebKeySetHandler jsonWebKeySetHandler;
  private final IssuerAcceptabilityHandler issuerAcceptabilityHandler;
  
  /**
   * Constructor.
   * @param jsonWebKeySetHandler         Handler for obtaining JWKs
   * @param issuerAcceptabilityHandler   Handler for validating issuers found in the JWT.
   */
<span class="fc" id="L72">  public JwtValidatorVertxImpl(JsonWebKeySetHandler jsonWebKeySetHandler, IssuerAcceptabilityHandler issuerAcceptabilityHandler) {</span>
<span class="fc" id="L73">    this.jsonWebKeySetHandler = jsonWebKeySetHandler;</span>
<span class="fc" id="L74">    this.issuerAcceptabilityHandler = issuerAcceptabilityHandler;</span>
<span class="fc" id="L75">    this.permittedAlgs = new HashSet&lt;&gt;(DEFAULT_PERMITTED_ALGS);</span>
<span class="fc" id="L76">  }</span>

  @Override
  public Set&lt;String&gt; getPermittedAlgorithms() {
<span class="fc" id="L80">    return ImmutableSet.copyOf(permittedAlgs);</span>
  }

  @Override
  public JwtValidator setPermittedAlgorithms(Set&lt;String&gt; algorithms) throws NoSuchAlgorithmException {
<span class="fc" id="L85">    Set&lt;String&gt; copy = new HashSet&lt;&gt;();</span>
<span class="fc bfc" id="L86" title="All 2 branches covered.">    for (String alg : algorithms) {</span>
<span class="fc bfc" id="L87" title="All 2 branches covered.">      if (!DEFAULT_PERMITTED_ALGS.contains(alg)) {</span>
<span class="fc" id="L88">        throw new NoSuchAlgorithmException();</span>
      } else {
<span class="fc" id="L90">        copy.add(alg);</span>
      }
<span class="fc" id="L92">    }</span>
<span class="fc" id="L93">    this.permittedAlgs = copy;</span>
<span class="fc" id="L94">    return this;</span>
  }

  @Override
  public JwtValidator addPermittedAlgorithm(String algorithm) throws NoSuchAlgorithmException {
<span class="fc bfc" id="L99" title="All 2 branches covered.">    if (!DEFAULT_PERMITTED_ALGS.contains(algorithm)) {</span>
<span class="fc" id="L100">      throw new NoSuchAlgorithmException();</span>
    } else {
<span class="fc" id="L102">      permittedAlgs.add(algorithm);</span>
    }
<span class="fc" id="L104">    return this;</span>
  }
  
  /**
   * Set the maximum amount of time that can pass between the exp and now.
   * @param timeLeeway the maximum amount of time that can pass between the exp and now.
   */
  @Override
  public JwtValidator setTimeLeeway(Duration timeLeeway) {
<span class="fc" id="L113">    this.timeLeewayMilliseconds = timeLeeway.toMillis();</span>
<span class="fc" id="L114">    return this;</span>
  }

  /**
   * Set the minimum amount of time that JWKs (and OpenID Discovery data) will be cached for.
   * @param minKeyCacheLifetime the minimum amount of time that JWKs (and OpenID Discovery data) will be cached for.
   */
  @Override
  public JwtValidator setMinimumKeyCacheLifetime(Duration minKeyCacheLifetime) {
<span class="nc" id="L123">    this.minimumKeyCacheLifetime = minKeyCacheLifetime.toMillis();</span>
<span class="nc" id="L124">    return this;</span>
  }

  /**
   * Set to true if the token is required to have an exp claim.
   * @param requireExp true if the token is required to have an exp claim.
   */
  @Override
  public JwtValidator setRequireExp(boolean requireExp) {
<span class="fc" id="L133">    this.requireExp = requireExp;</span>
<span class="fc" id="L134">    return this;</span>
  }

  /**
   * Set to true if the token is required to have an nbf claim.
   * @param requireNbf true if the token is required to have an nbf claim.
   */
  @Override
  public JwtValidator setRequireNbf(boolean requireNbf) {
<span class="fc" id="L143">    this.requireNbf = requireNbf;</span>
<span class="fc" id="L144">    return this;</span>
  }
  
  /**
   * Validate the token and either throw an exception or return it's constituent parts.
   * @param token             The token.
   * @param requiredAudList   List of audiences, all of which must be claimed by the token. If null the defaultRequiredAud is used.
   * @param ignoreRequiredAud Do not check for required audiences.
   * @return The token's parts.
   */
  @Override
  public Future&lt;Jwt&gt; validateToken(
          String issuer
          , String token
          , List&lt;String&gt; requiredAudList
          , boolean ignoreRequiredAud
  ) {
    
    Jwt jwt;
    try {
<span class="fc" id="L164">      jwt = Jwt.parseJws(token);</span>
<span class="fc" id="L165">    } catch (Throwable ex) {</span>
<span class="pc bpc" id="L166" title="1 of 2 branches missed.">      if (logger.isTraceEnabled()) {</span>
<span class="fc" id="L167">        logger.error(&quot;Parse of JWT ({}) failed: &quot;, token, ex);</span>
      } else {
<span class="nc" id="L169">        logger.error(&quot;Parse of JWT failed: &quot;, ex);</span>
      }
<span class="fc" id="L171">      return Future.failedFuture(new IllegalArgumentException(&quot;Parse of signed JWT failed&quot;, ex));</span>
<span class="fc" id="L172">    }</span>

    try {
<span class="fc" id="L175">      validateAlgorithm(jwt.getAlgorithm());</span>
<span class="fc" id="L176">      String kid = jwt.getKid();</span>

<span class="pc bpc" id="L178" title="1 of 2 branches missed.">      if (jwt.getPayloadSize() == 0) {</span>
<span class="nc" id="L179">        logger.error(&quot;No payload claims found in JWT&quot;);</span>
<span class="nc" id="L180">        return Future.failedFuture(new IllegalArgumentException(&quot;Parse of signed JWT failed&quot;));</span>
      }

<span class="fc" id="L183">      return jsonWebKeySetHandler.findJwk(issuer, kid)</span>
<span class="fc" id="L184">              .onFailure(ex -&gt; {</span>
<span class="fc" id="L185">                logger.warn(&quot;Failed to find JWK for {} ({}): &quot;, kid, issuer, ex);</span>
<span class="fc" id="L186">              })</span>
<span class="fc" id="L187">              .compose(jwk -&gt; {</span>
                try {
<span class="fc" id="L189">                  verify(jwk, jwt);</span>

<span class="fc" id="L191">                  long now = System.currentTimeMillis();</span>
<span class="fc" id="L192">                  validateIssuer(jwt, issuer);</span>
<span class="fc" id="L193">                  validateNbf(jwt, now);</span>
<span class="fc" id="L194">                  validateExp(jwt, now);</span>
<span class="fc" id="L195">                  validateAud(jwt, requiredAudList, ignoreRequiredAud);</span>
<span class="fc" id="L196">                  validateSub(jwt);</span>

<span class="fc" id="L198">                  return Future.succeededFuture(jwt);</span>
<span class="fc" id="L199">                } catch (Throwable ex) {</span>
<span class="fc" id="L200">                  logger.info(&quot;Validation of {} token failed: &quot;, jwt.getAlgorithm(), ex);</span>
<span class="fc" id="L201">                  return Future.failedFuture(new IllegalArgumentException(&quot;Validation of &quot; + jwt.getAlgorithm() + &quot; signed JWT failed&quot;, ex));</span>
                }
              });
<span class="fc" id="L204">    } catch (Throwable ex) {</span>
<span class="fc" id="L205">      logger.error(&quot;Failed to process token: &quot;, ex);</span>
<span class="fc" id="L206">      return Future.failedFuture(ex);</span>
    }
  }

  private void validateIssuer(Jwt jwt, String externalIssuer) {
<span class="fc" id="L211">    String tokenIssuer = jwt.getIssuer();</span>

    // empty issuer is never allowed
<span class="fc bfc" id="L214" title="All 2 branches covered.">    if (Strings.isNullOrEmpty(tokenIssuer)) {</span>
<span class="fc" id="L215">      throw new IllegalStateException(&quot;No issuer in token.&quot;);</span>
    }
    
<span class="fc bfc" id="L218" title="All 2 branches covered.">    if (!issuerAcceptabilityHandler.isAcceptable(tokenIssuer)) {</span>
<span class="fc" id="L219">      throw new IllegalStateException(&quot;Issuer from token (&quot; + tokenIssuer + &quot;) is not acceptable.&quot;);</span>
    }
    
<span class="pc bpc" id="L222" title="1 of 2 branches missed.">    if (externalIssuer != null) {</span>
<span class="pc bpc" id="L223" title="1 of 2 branches missed.">      if (!externalIssuer.equals(tokenIssuer)) {</span>
<span class="nc" id="L224">        throw new IllegalStateException(&quot;Issuer from token (&quot; + tokenIssuer + &quot;) does not match expected issuer (&quot; + externalIssuer + &quot;).&quot;);</span>
      }
    }
<span class="fc" id="L227">  }</span>
  
  private void verify(JWK jwk, Jwt jwt) throws IllegalArgumentException {

    // empty signature is never allowed
<span class="pc bpc" id="L232" title="1 of 2 branches missed.">    if (Strings.isNullOrEmpty(jwt.getSignature())) {</span>
<span class="nc" id="L233">      throw new IllegalStateException(&quot;No signature in token.&quot;);</span>
    }

<span class="fc" id="L236">    requireNonNull(jwk, &quot;JWK not set&quot;);</span>
    
    // if we only allow secure alg, then none is not a valid option
<span class="pc bpc" id="L239" title="1 of 2 branches missed.">    if (&quot;none&quot;.equals(jwk.getAlgorithm())) {</span>
<span class="nc" id="L240">      throw new IllegalStateException(&quot;Algorithm \&quot;none\&quot; not allowed&quot;);</span>
    }

<span class="fc" id="L243">    byte[] payloadInput = B64DECODER.decode(jwt.getSignature());</span>

<span class="fc" id="L245">    byte[] signingInput = jwt.getSignatureBase().getBytes(StandardCharsets.UTF_8);</span>

    try {
<span class="fc" id="L248">      JWS jws = new JWS(jwk);</span>
<span class="fc bfc" id="L249" title="All 2 branches covered.">      if (!jws.verify(payloadInput, signingInput)) {</span>
<span class="fc" id="L250">        throw new IllegalArgumentException(&quot;Signature verification failed&quot;);</span>
      }
<span class="fc" id="L252">    } catch (Throwable ex) {</span>
<span class="fc" id="L253">      logger.warn(&quot;Signature verification failed: &quot;, ex);</span>
<span class="fc" id="L254">      throw new IllegalArgumentException(&quot;Signature verification failed&quot;, ex);</span>
<span class="fc" id="L255">    }</span>
<span class="fc" id="L256">  }</span>

  private void validateSub(Jwt jwt) throws IllegalArgumentException {
<span class="fc bfc" id="L259" title="All 2 branches covered.">    if (Strings.isNullOrEmpty(jwt.getSubject())) {</span>
<span class="fc" id="L260">      throw new IllegalArgumentException(&quot;No subject specified in token&quot;);</span>
    }
<span class="fc" id="L262">  }</span>

  private void validateAud(Jwt jwt, List&lt;String&gt; requiredAudList, boolean ignoreRequiredAud) throws IllegalArgumentException {
<span class="pc bpc" id="L265" title="1 of 6 branches missed.">    if ((requiredAudList == null) || (!ignoreRequiredAud &amp;&amp; requiredAudList.isEmpty())) {</span>
<span class="fc" id="L266">      throw new IllegalStateException(&quot;Required audience not set&quot;);</span>
    }
<span class="pc bpc" id="L268" title="1 of 2 branches missed.">    if (jwt.getAudience() == null) {</span>
<span class="nc" id="L269">      throw new IllegalArgumentException(&quot;Token does not include aud claim&quot;);</span>
    }
<span class="fc bfc" id="L271" title="All 2 branches covered.">    for (String aud : jwt.getAudience()) {</span>
<span class="fc bfc" id="L272" title="All 2 branches covered.">      for (String requiredAud : requiredAudList) {</span>
<span class="fc bfc" id="L273" title="All 2 branches covered.">        if (requiredAud.equals(aud)) {</span>
<span class="fc" id="L274">          return;</span>
        }
<span class="fc" id="L276">      }</span>
<span class="fc" id="L277">    }</span>
<span class="pc bpc" id="L278" title="1 of 2 branches missed.">    if (!ignoreRequiredAud) {</span>
<span class="fc bfc" id="L279" title="All 2 branches covered.">      if (requiredAudList.size() == 1) {</span>
<span class="fc" id="L280">        logger.warn(&quot;Required audience ({}) not found in token aud claim: {}&quot;, requiredAudList.get(0), jwt.getAudience());</span>
      } else {
<span class="fc" id="L282">        logger.warn(&quot;None of the required audiences ({}) found in token aud claim: {}&quot;, requiredAudList, jwt.getAudience());</span>
      }
<span class="fc" id="L284">      throw new IllegalArgumentException(&quot;Required audience not found in token&quot;);</span>
    }
<span class="nc" id="L286">  }</span>

  private void validateExp(Jwt jwt, long now) throws IllegalArgumentException {
<span class="fc bfc" id="L289" title="All 2 branches covered.">    if (jwt.getExpiration() != null) {</span>
<span class="fc" id="L290">      long targetMs = now - timeLeewayMilliseconds;</span>
<span class="fc bfc" id="L291" title="All 2 branches covered.">      if (1000 * jwt.getExpiration() &lt; targetMs) {</span>
<span class="fc" id="L292">        logger.warn(&quot;Token exp = {} ({}), now = {} ({}), target = {} ({})&quot;, jwt.getExpiration(), jwt.getExpirationLocalDateTime(), now, LocalDateTime.ofInstant(Instant.ofEpochMilli(now), ZoneOffset.UTC), targetMs, LocalDateTime.ofInstant(Instant.ofEpochMilli(targetMs), ZoneOffset.UTC));</span>
<span class="fc" id="L293">        throw new IllegalArgumentException(&quot;Token is not valid after &quot; + jwt.getExpirationLocalDateTime());</span>
      }
<span class="pc bpc" id="L295" title="1 of 2 branches missed.">    } else if (requireExp) {</span>
<span class="fc" id="L296">      throw new IllegalArgumentException(&quot;Token does not specify exp&quot;);</span>
    }
<span class="fc" id="L298">  }</span>

  private void validateNbf(Jwt jwt, long now) throws IllegalArgumentException {
<span class="fc bfc" id="L301" title="All 2 branches covered.">    if (jwt.getNotBefore() != null) {</span>
<span class="fc" id="L302">      long targetMs = now + timeLeewayMilliseconds;</span>
<span class="fc bfc" id="L303" title="All 2 branches covered.">      if (1000 * jwt.getNotBefore() &gt; targetMs) {</span>
<span class="fc" id="L304">        logger.warn(&quot;Token nbf = {} ({}), now = {} ({}), target = {} ({})&quot;, jwt.getNotBefore(), jwt.getNotBeforeLocalDateTime(), now, LocalDateTime.ofInstant(Instant.ofEpochMilli(now), ZoneOffset.UTC), targetMs, LocalDateTime.ofInstant(Instant.ofEpochMilli(targetMs), ZoneOffset.UTC));</span>
<span class="fc" id="L305">        throw new IllegalArgumentException(&quot;Token is not valid until &quot; + jwt.getNotBeforeLocalDateTime());</span>
      }
<span class="fc bfc" id="L307" title="All 2 branches covered.">    } else if (requireNbf) {</span>
<span class="fc" id="L308">      throw new IllegalArgumentException(&quot;Token does not specify exp&quot;);</span>
    }
<span class="fc" id="L310">  }</span>

  private void validateAlgorithm(String algorithm) throws IllegalArgumentException {
<span class="pc bpc" id="L313" title="1 of 2 branches missed.">    if (algorithm == null) {</span>
<span class="nc" id="L314">      logger.warn(&quot;No signature algorithm in token.&quot;);</span>
<span class="nc" id="L315">      throw new IllegalArgumentException(&quot;Parse of signed JWT failed&quot;);</span>
    }
<span class="fc bfc" id="L317" title="All 2 branches covered.">    if (!permittedAlgs.contains(algorithm)) {</span>
<span class="fc" id="L318">      logger.warn(&quot;Failed to find algorithm \&quot;{}\&quot; in {}&quot;, algorithm, permittedAlgs);</span>
<span class="fc" id="L319">      throw new IllegalArgumentException(&quot;Parse of signed JWT failed&quot;);</span>
    }
<span class="fc" id="L321">  }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>