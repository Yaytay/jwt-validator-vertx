<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>JwtValidatorVertxImpl.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JWT Validator - Vertx</a> &gt; <a href="index.source.html" class="el_package">uk.co.spudsoft.jwtvalidatorvertx.impl</a> &gt; <span class="el_source">JwtValidatorVertxImpl.java</span></div><h1>JwtValidatorVertxImpl.java</h1><pre class="source lang-java linenums">package uk.co.spudsoft.jwtvalidatorvertx.impl;

import com.google.common.base.Strings;
import com.google.common.collect.ImmutableSet;
import io.vertx.core.Future;
import io.vertx.ext.auth.impl.jose.JWK;
import io.vertx.ext.auth.impl.jose.JWS;
import java.nio.charset.StandardCharsets;
import java.security.NoSuchAlgorithmException;
import java.time.Duration;
import java.time.Instant;
import java.time.LocalDateTime;
import java.time.ZoneOffset;
import java.util.Base64;
import java.util.List;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.HashSet;
import static java.util.Objects.requireNonNull;
import java.util.Set;
import uk.co.spudsoft.jwtvalidatorvertx.JsonWebKeySetHandler;
import uk.co.spudsoft.jwtvalidatorvertx.Jwt;
import uk.co.spudsoft.jwtvalidatorvertx.JwtValidator;

/**
 * Token validation for vertx - implementation of {@link uk.co.spudsoft.jwtvalidatorvertx.JwtValidator}.
 * @author Jim Talbut
 */
public class JwtValidatorVertxImpl implements JwtValidator {

  @SuppressWarnings(&quot;constantname&quot;)
<span class="fc" id="L33">  private static final Logger logger = LoggerFactory.getLogger(JwtValidatorVertxImpl.class);</span>

<span class="fc" id="L35">  private static final Base64.Decoder B64DECODER = Base64.getUrlDecoder();</span>
  
<span class="fc" id="L37">  private static final Set&lt;String&gt; DEFAULT_PERMITTED_ALGS = ImmutableSet.of(</span>
          JWS.EdDSA

          , JWS.ES256
          , JWS.ES384
          , JWS.ES512

          , JWS.PS256
          , JWS.PS384
          , JWS.PS512

          , JWS.ES256K

          , JWS.RS256
          , JWS.RS384
          , JWS.RS512
  );
  
  private Set&lt;String&gt; permittedAlgs;
  
<span class="fc" id="L57">  private boolean requireExp = true;</span>
<span class="fc" id="L58">  private boolean requireNbf = true;</span>
  
<span class="fc" id="L60">  private long timeLeewayMilliseconds = 0;</span>
<span class="fc" id="L61">  private long minimumKeyCacheLifetime = 0;</span>
  
  private final JsonWebKeySetHandler openIdDiscoveryHandler;
  
  /**
   * Constructor.
   * @param openIdDiscoveryHandler         Handler for obtaining OpenIdDiscovery data and JWKs
   */
<span class="fc" id="L69">  public JwtValidatorVertxImpl(JsonWebKeySetHandler openIdDiscoveryHandler) {</span>
<span class="fc" id="L70">    this.openIdDiscoveryHandler = openIdDiscoveryHandler;</span>
<span class="fc" id="L71">    this.permittedAlgs = new HashSet&lt;&gt;(DEFAULT_PERMITTED_ALGS);</span>
<span class="fc" id="L72">  }</span>

  @Override
  public Set&lt;String&gt; getPermittedAlgorithms() {
<span class="fc" id="L76">    return ImmutableSet.copyOf(permittedAlgs);</span>
  }

  @Override
  public JwtValidator setPermittedAlgorithms(Set&lt;String&gt; algorithms) throws NoSuchAlgorithmException {
<span class="fc" id="L81">    Set&lt;String&gt; copy = new HashSet&lt;&gt;();</span>
<span class="fc bfc" id="L82" title="All 2 branches covered.">    for (String alg : algorithms) {</span>
<span class="fc bfc" id="L83" title="All 2 branches covered.">      if (!DEFAULT_PERMITTED_ALGS.contains(alg)) {</span>
<span class="fc" id="L84">        throw new NoSuchAlgorithmException();</span>
      } else {
<span class="fc" id="L86">        copy.add(alg);</span>
      }
<span class="fc" id="L88">    }</span>
<span class="fc" id="L89">    this.permittedAlgs = copy;</span>
<span class="fc" id="L90">    return this;</span>
  }

  @Override
  public JwtValidator addPermittedAlgorithm(String algorithm) throws NoSuchAlgorithmException {
<span class="fc bfc" id="L95" title="All 2 branches covered.">    if (!DEFAULT_PERMITTED_ALGS.contains(algorithm)) {</span>
<span class="fc" id="L96">      throw new NoSuchAlgorithmException();</span>
    } else {
<span class="fc" id="L98">      permittedAlgs.add(algorithm);</span>
    }
<span class="fc" id="L100">    return this;</span>
  }
  
  /**
   * Set the maximum amount of time that can pass between the exp and now.
   * @param timeLeeway the maximum amount of time that can pass between the exp and now.
   */
  @Override
  public JwtValidator setTimeLeeway(Duration timeLeeway) {
<span class="fc" id="L109">    this.timeLeewayMilliseconds = timeLeeway.toMillis();</span>
<span class="fc" id="L110">    return this;</span>
  }

  /**
   * Set the minimum amount of time that JWKs (and OpenID Discovery data) will be cached for.
   * @param minKeyCacheLifetime the minimum amount of time that JWKs (and OpenID Discovery data) will be cached for.
   */
  @Override
  public JwtValidator setMinimumKeyCacheLifetime(Duration minKeyCacheLifetime) {
<span class="nc" id="L119">    this.minimumKeyCacheLifetime = minKeyCacheLifetime.toMillis();</span>
<span class="nc" id="L120">    return this;</span>
  }

  /**
   * Set to true if the token is required to have an exp claim.
   * @param requireExp true if the token is required to have an exp claim.
   */
  @Override
  public JwtValidator setRequireExp(boolean requireExp) {
<span class="fc" id="L129">    this.requireExp = requireExp;</span>
<span class="fc" id="L130">    return this;</span>
  }

  /**
   * Set to true if the token is required to have an nbf claim.
   * @param requireNbf true if the token is required to have an nbf claim.
   */
  @Override
  public JwtValidator setRequireNbf(boolean requireNbf) {
<span class="fc" id="L139">    this.requireNbf = requireNbf;</span>
<span class="fc" id="L140">    return this;</span>
  }
  
  /**
   * Validate the token and either throw an exception or return it's constituent parts.
   * @param token             The token.
   * @param requiredAudList   List of audiences, all of which must be claimed by the token. If null the defaultRequiredAud is used.
   * @param ignoreRequiredAud Do not check for required audiences.
   * @return The token's parts.
   */
  @Override
  public Future&lt;Jwt&gt; validateToken(
          String issuer
          , String token
          , List&lt;String&gt; requiredAudList
          , boolean ignoreRequiredAud
  ) {
    
    Jwt jwt;
    try {
<span class="fc" id="L160">      jwt = Jwt.parseJws(token);</span>
<span class="fc" id="L161">    } catch (Throwable ex) {</span>
<span class="fc" id="L162">      logger.error(&quot;Parse of JWT failed: &quot;, ex);</span>
<span class="fc" id="L163">      return Future.failedFuture(new IllegalArgumentException(&quot;Parse of signed JWT failed&quot;, ex));</span>
<span class="fc" id="L164">    }</span>

    try {
<span class="fc" id="L167">      validateAlgorithm(jwt.getAlgorithm());</span>
<span class="fc" id="L168">      String kid = jwt.getKid();</span>

<span class="pc bpc" id="L170" title="1 of 2 branches missed.">      if (jwt.getPayloadSize() == 0) {</span>
<span class="nc" id="L171">        logger.error(&quot;No payload claims found in JWT&quot;);</span>
<span class="nc" id="L172">        return Future.failedFuture(new IllegalArgumentException(&quot;Parse of signed JWT failed&quot;));</span>
      }

<span class="fc" id="L175">      return openIdDiscoveryHandler.findJwk(issuer, kid)</span>
<span class="fc" id="L176">              .compose(jwk -&gt; {</span>
                try {
<span class="fc" id="L178">                  verify(jwk, jwt);</span>

<span class="fc" id="L180">                  long now = System.currentTimeMillis();</span>
<span class="fc" id="L181">                  validateIssuer(jwt, issuer);</span>
<span class="fc" id="L182">                  validateNbf(jwt, now);</span>
<span class="fc" id="L183">                  validateExp(jwt, now);</span>
<span class="fc" id="L184">                  validateAud(jwt, requiredAudList, ignoreRequiredAud);</span>
<span class="fc" id="L185">                  validateSub(jwt);</span>

<span class="fc" id="L187">                  return Future.succeededFuture(jwt);</span>
<span class="fc" id="L188">                } catch (Throwable ex) {</span>
<span class="fc" id="L189">                  logger.info(&quot;Validation of {} token failed: &quot;, jwt.getAlgorithm(), ex);</span>
<span class="fc" id="L190">                  return Future.failedFuture(new IllegalArgumentException(&quot;Validation of &quot; + jwt.getAlgorithm() + &quot; signed JWT failed&quot;, ex));</span>
                }
              });
<span class="fc" id="L193">    } catch (Throwable ex) {</span>
<span class="fc" id="L194">      logger.error(&quot;Failed to process token: &quot;, ex);</span>
<span class="fc" id="L195">      return Future.failedFuture(ex);</span>
    }
  }

  private void validateIssuer(Jwt jwt, String externalIssuer) {
<span class="fc" id="L200">    String tokenIssuer = jwt.getIssuer();</span>

    // empty issuer is never allowed
<span class="pc bpc" id="L203" title="1 of 2 branches missed.">    if (Strings.isNullOrEmpty(tokenIssuer)) {</span>
<span class="nc" id="L204">      throw new IllegalStateException(&quot;No issuer in token.&quot;);</span>
    }
    
<span class="fc" id="L207">    openIdDiscoveryHandler.validateIssuer(tokenIssuer);</span>
    
<span class="pc bpc" id="L209" title="1 of 2 branches missed.">    if (externalIssuer != null) {</span>
<span class="pc bpc" id="L210" title="1 of 2 branches missed.">      if (!externalIssuer.equals(tokenIssuer)) {</span>
<span class="nc" id="L211">        throw new IllegalStateException(&quot;Issuer from token (&quot; + tokenIssuer + &quot;) does not match expected issuer (&quot; + externalIssuer + &quot;).&quot;);</span>
      }
    }
<span class="fc" id="L214">  }</span>
  
  private void verify(JWK jwk, Jwt jwt) throws IllegalArgumentException {

    // empty signature is never allowed
<span class="pc bpc" id="L219" title="1 of 2 branches missed.">    if (Strings.isNullOrEmpty(jwt.getSignature())) {</span>
<span class="nc" id="L220">      throw new IllegalStateException(&quot;No signature in token.&quot;);</span>
    }

<span class="fc" id="L223">    requireNonNull(jwk, &quot;JWK not set&quot;);</span>
    
    // if we only allow secure alg, then none is not a valid option
<span class="pc bpc" id="L226" title="1 of 2 branches missed.">    if (&quot;none&quot;.equals(jwk.getAlgorithm())) {</span>
<span class="nc" id="L227">      throw new IllegalStateException(&quot;Algorithm \&quot;none\&quot; not allowed&quot;);</span>
    }

<span class="fc" id="L230">    byte[] payloadInput = B64DECODER.decode(jwt.getSignature());</span>

<span class="fc" id="L232">    byte[] signingInput = jwt.getSignatureBase().getBytes(StandardCharsets.UTF_8);</span>

    try {
<span class="fc" id="L235">      JWS jws = new JWS(jwk);</span>
<span class="fc bfc" id="L236" title="All 2 branches covered.">      if (!jws.verify(payloadInput, signingInput)) {</span>
<span class="fc" id="L237">        throw new IllegalArgumentException(&quot;Signature verification failed&quot;);</span>
      }
<span class="fc" id="L239">    } catch (Throwable ex) {</span>
<span class="fc" id="L240">      logger.warn(&quot;Signature verification failed: &quot;, ex);</span>
<span class="fc" id="L241">      throw new IllegalArgumentException(&quot;Signature verification failed&quot;, ex);</span>
<span class="fc" id="L242">    }</span>
<span class="fc" id="L243">  }</span>

  private void validateSub(Jwt jwt) throws IllegalArgumentException {
<span class="fc bfc" id="L246" title="All 2 branches covered.">    if (Strings.isNullOrEmpty(jwt.getSubject())) {</span>
<span class="fc" id="L247">      throw new IllegalArgumentException(&quot;No subject specified in token&quot;);</span>
    }
<span class="fc" id="L249">  }</span>

  private void validateAud(Jwt jwt, List&lt;String&gt; requiredAudList, boolean ignoreRequiredAud) throws IllegalArgumentException {
<span class="pc bpc" id="L252" title="3 of 6 branches missed.">    if ((requiredAudList == null) || (!ignoreRequiredAud &amp;&amp; requiredAudList.isEmpty())) {</span>
<span class="nc" id="L253">      throw new IllegalStateException(&quot;Required audience not set&quot;);</span>
    }
<span class="pc bpc" id="L255" title="1 of 2 branches missed.">    if (jwt.getAudience() == null) {</span>
<span class="nc" id="L256">      throw new IllegalArgumentException(&quot;Token does not include aud claim&quot;);</span>
    }
<span class="fc bfc" id="L258" title="All 2 branches covered.">    for (String aud : jwt.getAudience()) {</span>
<span class="fc bfc" id="L259" title="All 2 branches covered.">      for (String requiredAud : requiredAudList) {</span>
<span class="fc bfc" id="L260" title="All 2 branches covered.">        if (requiredAud.equals(aud)) {</span>
<span class="fc" id="L261">          return;</span>
        }
<span class="fc" id="L263">      }</span>
<span class="fc" id="L264">    }</span>
<span class="pc bpc" id="L265" title="1 of 2 branches missed.">    if (!ignoreRequiredAud) {</span>
<span class="pc bpc" id="L266" title="1 of 2 branches missed.">      if (requiredAudList.size() == 1) {</span>
<span class="fc" id="L267">        logger.warn(&quot;Required audience ({}) not found in token aud claim: {}&quot;, requiredAudList.get(0), jwt.getAudience());</span>
      } else {
<span class="nc" id="L269">        logger.warn(&quot;None of the required audiences ({}) found in token aud claim: {}&quot;, requiredAudList, jwt.getAudience());</span>
      }
<span class="fc" id="L271">      throw new IllegalArgumentException(&quot;Required audience not found in token&quot;);</span>
    }
<span class="nc" id="L273">  }</span>

  private void validateExp(Jwt jwt, long now) throws IllegalArgumentException {
<span class="fc bfc" id="L276" title="All 2 branches covered.">    if (jwt.getExpiration() != null) {</span>
<span class="fc" id="L277">      long targetMs = now - timeLeewayMilliseconds;</span>
<span class="fc bfc" id="L278" title="All 2 branches covered.">      if (1000 * jwt.getExpiration() &lt; targetMs) {</span>
<span class="fc" id="L279">        logger.warn(&quot;Token exp = {} ({}), now = {} ({}), target = {} ({})&quot;, jwt.getExpiration(), jwt.getExpirationLocalDateTime(), now, LocalDateTime.ofInstant(Instant.ofEpochMilli(now), ZoneOffset.UTC), targetMs, LocalDateTime.ofInstant(Instant.ofEpochMilli(targetMs), ZoneOffset.UTC));</span>
<span class="fc" id="L280">        throw new IllegalArgumentException(&quot;Token is not valid after &quot; + jwt.getExpirationLocalDateTime());</span>
      }
<span class="pc bpc" id="L282" title="1 of 2 branches missed.">    } else if (requireExp) {</span>
<span class="fc" id="L283">      throw new IllegalArgumentException(&quot;Token does not specify exp&quot;);</span>
    }
<span class="fc" id="L285">  }</span>

  private void validateNbf(Jwt jwt, long now) throws IllegalArgumentException {
<span class="fc bfc" id="L288" title="All 2 branches covered.">    if (jwt.getNotBefore() != null) {</span>
<span class="fc" id="L289">      long targetMs = now + timeLeewayMilliseconds;</span>
<span class="fc bfc" id="L290" title="All 2 branches covered.">      if (1000 * jwt.getNotBefore() &gt; targetMs) {</span>
<span class="fc" id="L291">        logger.warn(&quot;Token nbf = {} ({}), now = {} ({}), target = {} ({})&quot;, jwt.getNotBefore(), jwt.getNotBeforeLocalDateTime(), now, LocalDateTime.ofInstant(Instant.ofEpochMilli(now), ZoneOffset.UTC), targetMs, LocalDateTime.ofInstant(Instant.ofEpochMilli(targetMs), ZoneOffset.UTC));</span>
<span class="fc" id="L292">        throw new IllegalArgumentException(&quot;Token is not valid until &quot; + jwt.getNotBeforeLocalDateTime());</span>
      }
<span class="fc bfc" id="L294" title="All 2 branches covered.">    } else if (requireNbf) {</span>
<span class="fc" id="L295">      throw new IllegalArgumentException(&quot;Token does not specify exp&quot;);</span>
    }
<span class="fc" id="L297">  }</span>

  private void validateAlgorithm(String algorithm) throws IllegalArgumentException {
<span class="pc bpc" id="L300" title="1 of 2 branches missed.">    if (algorithm == null) {</span>
<span class="nc" id="L301">      logger.warn(&quot;No signature algorithm in token.&quot;);</span>
<span class="nc" id="L302">      throw new IllegalArgumentException(&quot;Parse of signed JWT failed&quot;);</span>
    }
<span class="fc bfc" id="L304" title="All 2 branches covered.">    if (!permittedAlgs.contains(algorithm)) {</span>
<span class="fc" id="L305">      logger.warn(&quot;Failed to find algorithm \&quot;{}\&quot; in {}&quot;, algorithm, permittedAlgs);</span>
<span class="fc" id="L306">      throw new IllegalArgumentException(&quot;Parse of signed JWT failed&quot;);</span>
    }
<span class="fc" id="L308">  }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>