<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>AbstractTokenBuilder.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JWT Validator - Vertx</a> &gt; <a href="index.source.html" class="el_package">uk.co.spudsoft.jwtvalidatorvertx.impl</a> &gt; <span class="el_source">AbstractTokenBuilder.java</span></div><h1>AbstractTokenBuilder.java</h1><pre class="source lang-java linenums">/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package uk.co.spudsoft.jwtvalidatorvertx.impl;

import com.google.common.cache.Cache;
import io.vertx.core.json.JsonArray;
import io.vertx.core.json.JsonObject;
import java.nio.charset.StandardCharsets;
import java.security.SecureRandom;
import java.util.Arrays;
import java.util.Base64;
import java.util.Base64.Encoder;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import javax.annotation.Nullable;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import uk.co.spudsoft.jwtvalidatorvertx.AlgorithmAndKeyPair;
import uk.co.spudsoft.jwtvalidatorvertx.JsonWebAlgorithm;
import uk.co.spudsoft.jwtvalidatorvertx.TokenBuilder;




/**
 * Abstract implementation of TokenBuilder.
 * &lt;p&gt;
 * The actual creation of keys is left to a subclass to implement.
 * &lt;p&gt;
 * This class can perform all the work of a TokenBuilder implementation apart from the generation of keys, however most methods
 * are designed to be overrideable so that a specific implementation can do something different if that is useful.
 * @author jtalbut
 */
public abstract class AbstractTokenBuilder implements TokenBuilder {

  @SuppressWarnings(&quot;constantname&quot;)
<span class="fc" id="L41">  private static final Logger logger = LoggerFactory.getLogger(AbstractTokenBuilder.class);</span>

  /**
   * Base64 encoded that implementations may (should) use.
   */
<span class="fc" id="L46">  protected static final Encoder BASE64 = Base64.getUrlEncoder().withoutPadding();</span>
  /**
   * Secure random number generator that implementations may  use.
   */
<span class="fc" id="L50">  protected static final SecureRandom RANDOM = new SecureRandom();</span>
  
<span class="fc" id="L52">  private boolean headerNotValidBase64 = false;</span>
<span class="fc" id="L53">  private boolean payloadNotValidBase64 = false;</span>
<span class="fc" id="L54">  private boolean signatureNotValidBase64 = false;</span>
<span class="fc" id="L55">  private boolean headerNotJson = false;</span>
<span class="fc" id="L56">  private boolean payloadNotJson = false;</span>
<span class="fc" id="L57">  private boolean signatureNotValidHash = false;</span>
<span class="fc" id="L58">  private boolean kidInvalid = false;</span>
  
  /**
   * The key cache that is shared with the {@link uk.co.spudsoft.jwtvalidatorvertx.JwksHandler}.
   * &lt;p&gt;
   * Note that it is the TokenBuilder that is responsible for causing keys to be created and cached, the 
   * {@link uk.co.spudsoft.jwtvalidatorvertx.JwksHandler} just makes them available.
   */
  protected final Cache&lt;String, AlgorithmAndKeyPair&gt; keyCache;

  /**
   * Constructor.
   * 
   * @param keyCache The key cache that is shared with the {@link uk.co.spudsoft.jwtvalidatorvertx.JwksHandler}.
   */
<span class="fc" id="L73">  public AbstractTokenBuilder(Cache&lt;String, AlgorithmAndKeyPair&gt; keyCache) {</span>
<span class="fc" id="L74">    this.keyCache = keyCache;</span>
<span class="fc" id="L75">  }</span>

  @Override
  public TokenBuilder setHeaderNotValidBase64(boolean headerNotValidBase64) {
<span class="fc" id="L79">    this.headerNotValidBase64 = headerNotValidBase64;</span>
<span class="fc" id="L80">    return this;</span>
  }

  @Override
  public TokenBuilder setPayloadNotValidBase64(boolean payloadNotValidBase64) {
<span class="fc" id="L85">    this.payloadNotValidBase64 = payloadNotValidBase64;</span>
<span class="fc" id="L86">    return  this;</span>
  }

  @Override
  public TokenBuilder setSignatureNotValidBase64(boolean signatureNotValidBase64) {
<span class="fc" id="L91">    this.signatureNotValidBase64 = signatureNotValidBase64;</span>
<span class="fc" id="L92">    return this;</span>
  }

  @Override
  public TokenBuilder setHeaderNotJson(boolean headerNotJson) {
<span class="fc" id="L97">    this.headerNotJson = headerNotJson;</span>
<span class="fc" id="L98">    return this;</span>
  }

  @Override
  public TokenBuilder setPayloadNotJson(boolean payloadNotJson) {
<span class="fc" id="L103">    this.payloadNotJson = payloadNotJson;</span>
<span class="fc" id="L104">    return this;</span>
  }

  @Override
  public TokenBuilder setSignatureNotValidHash(boolean signatureNotValidHash) {
<span class="fc" id="L109">    this.signatureNotValidHash = signatureNotValidHash;</span>
<span class="fc" id="L110">    return this;</span>
  }
  
  @Override
  public TokenBuilder setKidInvalid(boolean kidInvalid) {
<span class="fc" id="L115">    this.kidInvalid = kidInvalid;</span>
<span class="fc" id="L116">    return this;</span>
  }
  
  @Override
  public String buildToken(JsonWebAlgorithm jwa,
           String kid,
           String iss,
           String sub,
           List&lt;String&gt; aud,
           Long nbf,
           Long exp,
           Map&lt;String, Object&gt; otherClaims
  ) throws Exception {

<span class="fc" id="L130">    JsonObject header = generateHeaderNode(kid, jwa);</span>

<span class="fc" id="L132">    JsonObject claims = generateClaimsNode(iss, sub, exp, nbf, aud, otherClaims);</span>

<span class="fc" id="L134">    String headerBase64 = base64Header(header);</span>

<span class="fc" id="L136">    String claimsBase64 = base64Claims(claims);</span>

    String signatureBase64;
    
<span class="fc bfc" id="L140" title="All 4 branches covered.">    if ((kid != null) &amp;&amp; (jwa != JsonWebAlgorithm.none)) {</span>
<span class="fc" id="L141">      byte[] signature = generateSignature(kid, jwa, headerBase64, claimsBase64);</span>
<span class="fc bfc" id="L142" title="All 2 branches covered.">      if (signatureNotValidHash) {</span>
<span class="fc" id="L143">        signature = Arrays.copyOf(signature, signature.length - 1);</span>
      }
<span class="fc" id="L145">      signatureBase64 = base64Signature(signature);</span>
<span class="fc" id="L146">    } else {</span>
<span class="fc" id="L147">      signatureBase64 = &quot;&quot;;</span>
    }

<span class="fc" id="L150">    String token = constructToken(headerBase64, claimsBase64, signatureBase64);</span>

<span class="fc" id="L152">    logger.debug(&quot;{} Token: {}&quot;, jwa, token);</span>

<span class="fc" id="L154">    return token;</span>
  }

  /**
   * Helper method to generate the token header node.
   * @param kid The key ID.
   * @param algorithm The algorithm.
   * @return The created JsonObject header node.
   */
  protected JsonObject generateHeaderNode(String kid, JsonWebAlgorithm algorithm) {
<span class="fc" id="L164">    JsonObject header = new JsonObject();</span>
<span class="fc" id="L165">    header.put(&quot;typ&quot;, &quot;JWT&quot;);</span>
<span class="fc bfc" id="L166" title="All 2 branches covered.">    if (kid != null) {</span>
<span class="fc bfc" id="L167" title="All 2 branches covered.">      if (kidInvalid) {</span>
<span class="fc" id="L168">        header.put(&quot;kid&quot;, &quot;INVALID&quot;);</span>
      } else {
<span class="fc" id="L170">        header.put(&quot;kid&quot;, kid);</span>
      }
    }
<span class="fc" id="L173">    header.put(&quot;alg&quot;, algorithm.getName());</span>
<span class="fc" id="L174">    return header;</span>
  }

  /**
   * Helper method to build the payload for a token.
   * @param iss The iss (issuer) claim.
   * @param sub The sub (subject) claim.
   * @param exp The exp (expiry) claim.
   * @param nbf The nbf (not before) claim.
   * @param aud The aud (audience) claim.
   * @param otherClaims Map of other claims that are to be added.
   * Any claims in otherClaims will override anything else added to the claims.
   * @return a JsonObject of the payload for a token.
   */
  protected JsonObject generateClaimsNode(
          @Nullable String iss
          , @Nullable String sub
          , @Nullable Long exp
          , @Nullable Long nbf
          , @Nullable List&lt;String&gt; aud
          , @Nullable Map&lt;String, Object&gt; otherClaims
  ) {
<span class="fc" id="L196">    JsonObject claims = new JsonObject();</span>
<span class="fc bfc" id="L197" title="All 2 branches covered.">    if (sub != null) {</span>
<span class="fc" id="L198">      claims.put(&quot;sub&quot;, sub);</span>
    }
<span class="fc bfc" id="L200" title="All 2 branches covered.">    if (iss != null) {</span>
<span class="fc" id="L201">      claims.put(&quot;iss&quot;, iss);</span>
    }
<span class="fc bfc" id="L203" title="All 2 branches covered.">    if (exp != null) {</span>
<span class="fc" id="L204">      claims.put(&quot;exp&quot;, exp);</span>
    }
<span class="fc bfc" id="L206" title="All 2 branches covered.">    if (nbf != null) {</span>
<span class="fc" id="L207">      claims.put(&quot;nbf&quot;, nbf);</span>
    }
<span class="fc bfc" id="L209" title="All 2 branches covered.">    if (aud != null) {</span>
<span class="pc bpc" id="L210" title="1 of 2 branches missed.">      if (aud.size() == 1) {</span>
<span class="fc" id="L211">        claims.put(&quot;aud&quot;, aud.get(0));</span>
      } else {
<span class="nc" id="L213">        JsonArray array = new JsonArray();</span>
<span class="nc" id="L214">        claims.put(&quot;aud&quot;, array);</span>
<span class="nc bnc" id="L215" title="All 2 branches missed.">        for (String member : aud) {</span>
<span class="nc" id="L216">          array.add(member);</span>
<span class="nc" id="L217">        }</span>
      }
    }
<span class="pc bpc" id="L220" title="1 of 2 branches missed.">    if (otherClaims != null) {</span>
<span class="fc bfc" id="L221" title="All 2 branches covered.">      for (Entry&lt;String, Object&gt; claim : otherClaims.entrySet()) {</span>
<span class="fc" id="L222">        claims.put(claim.getKey(), claim.getValue());</span>
<span class="fc" id="L223">      }</span>
    }
<span class="fc" id="L225">    return claims;</span>
  }

  /**
   * Helper method to convert a JsonObject into a base64 representation.
   * Optionally provides two ways in which the result can be invalidated.
   * @param notJson If the JSON should be broken before the base64 encoding.
   * @param brokenBase64 The the base64 encoding should be broken.
   * @param json The JSON to be encoded.
   * @return The JSON encoded as base64 (possibly broken).
   */
  protected String base64JSon(boolean notJson, boolean brokenBase64, JsonObject json) {
<span class="fc" id="L237">    String jsonString = json.toString();</span>
<span class="fc bfc" id="L238" title="All 2 branches covered.">    if (notJson) {</span>
<span class="fc" id="L239">      jsonString = jsonString.replaceAll(&quot;\&quot;&quot;, &quot;&quot;);</span>
    }
<span class="fc" id="L241">    String base64 = BASE64.encodeToString(jsonString.getBytes(StandardCharsets.UTF_8));</span>
<span class="fc bfc" id="L242" title="All 2 branches covered.">    if (brokenBase64) {</span>
<span class="fc" id="L243">      base64 = base64.substring(0, base64.length() - 1);</span>
    }
<span class="fc" id="L245">    return base64;</span>
  }

  /**
   * Helper method to convert the header to base64, possibly breaking it.
   * Uses the headerNotJson and headerNotValidBase64 fields to determine whether the result should be valid.
   * @param header The header to convert.
   * @return The JSON encoded as base64 (possibly broken).
   */
  protected String base64Header(JsonObject header) {
<span class="fc" id="L255">    return base64JSon(headerNotJson, headerNotValidBase64, header);</span>
  }

  /**
   * Helper method to convert the payload to base64, possibly breaking it.
   * Uses the payloadNotJson and payloadNotValidBase64 fields to determine whether the result should be valid.
   * @param claims The claims to convert.
   * @return The JSON encoded as base64 (possibly broken).
   */
  protected String base64Claims(JsonObject claims) {
<span class="fc" id="L265">    return base64JSon(payloadNotJson, payloadNotValidBase64, claims);</span>
  }

  /**
   * Sign the token header and claims using the specified key.
   * @param kid The key to use to sign the header and claims, if this key is not found in the cache it will be generated.
   * @param algorithm The algorithm to use to generate the key, if it is not found in the cache.
   * @param headerBase64 The header to include in the signature.
   * @param claimsBase64 The claims to include in the signature.
   * @return The signature of the header and claims.
   * @throws Exception If the security subsystem is unable to complete the operation.
   */
  protected abstract byte[] generateSignature(String kid, JsonWebAlgorithm algorithm, String headerBase64, String claimsBase64) throws Exception;

  /**
   * Helper method to base6t4 encode the signature, possibly breaking it.
   * Uses the signatureNotValidBase64 fields to determine whether the result should be valid.
   * @param signature The signature of the header and payload.
   * @return The base64 encoded signature.
   */
  protected String base64Signature(byte[] signature) {
<span class="fc" id="L286">    String signatureBase64 = BASE64.encodeToString(signature);</span>
<span class="fc bfc" id="L287" title="All 2 branches covered.">    if (signatureNotValidBase64) {</span>
<span class="fc" id="L288">      signatureBase64 = signatureBase64.substring(0, signatureBase64.length() - 1);</span>
    }
<span class="fc" id="L290">    return signatureBase64;</span>
  }

  /**
   * Helper method to concatenate the three parts of the token.
   * @param headerBase64 The header, base 64 encoded.
   * @param claimsBase64 The claims, base 64 encoded.
   * @param signatureBase64 The signature, base 64 encoded.
   * @return The final JWS.
   */
  protected String constructToken(String headerBase64, String claimsBase64, String signatureBase64) {
<span class="fc" id="L301">    String token = headerBase64 + &quot;.&quot; + claimsBase64 + &quot;.&quot; + signatureBase64;</span>
<span class="fc" id="L302">    return token;</span>
  }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>