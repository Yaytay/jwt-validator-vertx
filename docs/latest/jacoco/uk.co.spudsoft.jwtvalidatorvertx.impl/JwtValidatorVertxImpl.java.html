<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>JwtValidatorVertxImpl.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JWT Validator - Vertx</a> &gt; <a href="index.source.html" class="el_package">uk.co.spudsoft.jwtvalidatorvertx.impl</a> &gt; <span class="el_source">JwtValidatorVertxImpl.java</span></div><h1>JwtValidatorVertxImpl.java</h1><pre class="source lang-java linenums">package uk.co.spudsoft.jwtvalidatorvertx.impl;

import com.google.common.base.Strings;
import io.vertx.core.Future;
import java.nio.charset.StandardCharsets;
import java.time.LocalDateTime;
import java.time.ZoneOffset;
import java.util.Base64;
import java.util.List;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import uk.co.spudsoft.jwtvalidatorvertx.JWK;
import uk.co.spudsoft.jwtvalidatorvertx.JWT;
import uk.co.spudsoft.jwtvalidatorvertx.JsonWebAlgorithm;

import java.util.EnumSet;
import uk.co.spudsoft.jwtvalidatorvertx.JsonWebKeySetHandler;
import uk.co.spudsoft.jwtvalidatorvertx.JwtValidatorVertx;

/**
 * Token validation for vertx - implementation of {@link uk.co.spudsoft.jwtvalidatorvertx.JwtValidatorVertx}.
 * @author Jim Talbut
 */
public class JwtValidatorVertxImpl implements JwtValidatorVertx {

  @SuppressWarnings(&quot;constantname&quot;)
<span class="fc" id="L27">  private static final Logger logger = LoggerFactory.getLogger(JwtValidatorVertxImpl.class);</span>

<span class="fc" id="L29">  private static final Base64.Decoder B64DECODER = Base64.getUrlDecoder();</span>
  
<span class="fc" id="L31">  private static final EnumSet&lt;JsonWebAlgorithm&gt; DEFAULT_PERMITTED_ALGS = EnumSet.of(</span>
          JsonWebAlgorithm.RS256, JsonWebAlgorithm.RS384, JsonWebAlgorithm.RS512
  );
  
  private EnumSet&lt;JsonWebAlgorithm&gt; permittedAlgs;
  
<span class="fc" id="L37">  private boolean requireExp = true;</span>
<span class="fc" id="L38">  private boolean requireNbf = true;</span>
  
<span class="fc" id="L40">  private long timeLeewaySeconds = 0;</span>
  
  private final JsonWebKeySetHandler openIdDiscoveryHandler;
  
  /**
   * Constructor.
   * @param openIdDiscoveryHandler         Handler for obtaining OpenIdDiscovery data and JWKs
   */
<span class="fc" id="L48">  public JwtValidatorVertxImpl(JsonWebKeySetHandler openIdDiscoveryHandler) {</span>
<span class="fc" id="L49">    this.openIdDiscoveryHandler = openIdDiscoveryHandler;</span>
<span class="fc" id="L50">    this.permittedAlgs = EnumSet.copyOf(DEFAULT_PERMITTED_ALGS);</span>
<span class="fc" id="L51">  }</span>

  @Override
  public EnumSet&lt;JsonWebAlgorithm&gt; getPermittedAlgorithms() {
<span class="nc" id="L55">    return EnumSet.copyOf(permittedAlgs);</span>
  }

  @Override
  public JwtValidatorVertx setPermittedAlgorithms(EnumSet&lt;JsonWebAlgorithm&gt; algorithms) {
<span class="nc" id="L60">    this.permittedAlgs = EnumSet.copyOf(algorithms);</span>
<span class="nc" id="L61">    return this;</span>
  }

  @Override
  public JwtValidatorVertx addPermittedAlgorithm(JsonWebAlgorithm algorithm) {
<span class="fc" id="L66">    this.permittedAlgs.add(algorithm);</span>
<span class="fc" id="L67">    return this;</span>
  }
  
  /**
   * Set the maximum amount of time that can pass between the exp and now.
   * @param timeLeewaySeconds the maximum amount of time that can pass between the exp and now.
   */
  @Override
  public JwtValidatorVertx setTimeLeewaySeconds(long timeLeewaySeconds) {
<span class="fc" id="L76">    this.timeLeewaySeconds = timeLeewaySeconds;</span>
<span class="fc" id="L77">    return this;</span>
  }

  /**
   * Set to true if the token is required to have an exp claim.
   * @param requireExp true if the token is required to have an exp claim.
   */
  @Override
  public JwtValidatorVertx setRequireExp(boolean requireExp) {
<span class="fc" id="L86">    this.requireExp = requireExp;</span>
<span class="fc" id="L87">    return this;</span>
  }

  /**
   * Set to true if the token is required to have an nbf claim.
   * @param requireNbf true if the token is required to have an nbf claim.
   */
  @Override
  public JwtValidatorVertx setRequireNbf(boolean requireNbf) {
<span class="fc" id="L96">    this.requireNbf = requireNbf;</span>
<span class="fc" id="L97">    return this;</span>
  }
  
  /**
   * Validate the token and either throw an exception or return it's constituent parts.
   * @param token             The token.
   * @param requiredAudList   List of audiences, all of which must be claimed by the token. If null the defaultRequiredAud is used.
   * @param ignoreRequiredAud Do not check for required audiences.
   * @return The token's parts.
   */
  @Override
  public Future&lt;JWT&gt; validateToken(
          String token
          , List&lt;String&gt; requiredAudList
          , boolean ignoreRequiredAud
  ) {
    
    JWT jwt;
    try {
<span class="fc" id="L116">      jwt = JWT.parseJws(token);</span>
<span class="fc" id="L117">    } catch (Throwable ex) {</span>
<span class="fc" id="L118">      logger.error(&quot;Parse of JWT failed: &quot;, ex);</span>
<span class="fc" id="L119">      return Future.failedFuture(new IllegalArgumentException(&quot;Parse of signed JWT failed&quot;, ex));</span>
<span class="fc" id="L120">    }</span>

    try {
<span class="fc" id="L123">      JsonWebAlgorithm jwa = validateAlgorithm(jwt.getAlgorithm());</span>
<span class="fc" id="L124">      jwt.getKid();</span>

<span class="pc bpc" id="L126" title="1 of 2 branches missed.">      if (jwt.getPayloadSize() == 0) {</span>
<span class="nc" id="L127">        logger.error(&quot;No payload claims found in JWT&quot;);</span>
<span class="nc" id="L128">        return Future.failedFuture(new IllegalArgumentException(&quot;Parse of signed JWT failed&quot;));</span>
      }
<span class="fc" id="L130">      String issuer = jwt.getIssuer();</span>

<span class="fc" id="L132">      openIdDiscoveryHandler.validateIssuer(issuer);</span>

<span class="fc" id="L134">      return jwt.getJwk(openIdDiscoveryHandler)</span>
<span class="fc" id="L135">              .compose(jwk -&gt; {</span>
                try {
<span class="fc" id="L137">                  verify(jwa, jwk, jwt);</span>

<span class="fc" id="L139">                  long nowSeconds = System.currentTimeMillis() / 1000;</span>
<span class="fc" id="L140">                  validateNbf(jwt, nowSeconds);</span>
<span class="fc" id="L141">                  validateExp(jwt, nowSeconds);</span>
<span class="fc" id="L142">                  validateAud(jwt, requiredAudList, ignoreRequiredAud);</span>
<span class="fc" id="L143">                  validateSub(jwt);</span>

<span class="fc" id="L145">                  return Future.succeededFuture(jwt);</span>
<span class="fc" id="L146">                } catch (Throwable ex) {</span>
<span class="fc" id="L147">                  logger.info(&quot;Validation of {} token failed: &quot;, jwt.getAlgorithm(), ex);</span>
<span class="fc" id="L148">                  return Future.failedFuture(new IllegalArgumentException(&quot;Validation of &quot; + jwt.getAlgorithm() + &quot; signed JWT failed&quot;, ex));</span>
                }
              });
<span class="fc" id="L151">    } catch (Throwable ex) {</span>
<span class="fc" id="L152">      logger.error(&quot;Failed to process token: &quot;, ex);</span>
<span class="fc" id="L153">      return Future.failedFuture(ex);</span>
    }
  }

  private void verify(JsonWebAlgorithm jwa, JWK&lt;?&gt; jwk, JWT jwt) throws IllegalArgumentException {

    // empty signature is never allowed
<span class="pc bpc" id="L160" title="1 of 2 branches missed.">    if (Strings.isNullOrEmpty(jwt.getSignature())) {</span>
<span class="nc" id="L161">      throw new IllegalStateException(&quot;No signature in token.&quot;);</span>
    }

    // if we only allow secure alg, then none is not a valid option
<span class="pc bpc" id="L165" title="1 of 2 branches missed.">    if (JsonWebAlgorithm.none == jwa) {</span>
<span class="nc" id="L166">      throw new IllegalStateException(&quot;Algorithm \&quot;none\&quot; not allowed&quot;);</span>
    }

<span class="fc" id="L169">    byte[] payloadInput = B64DECODER.decode(jwt.getSignature());</span>

<span class="fc" id="L171">    byte[] signingInput = jwt.getSignatureBase().getBytes(StandardCharsets.UTF_8);</span>

    try {
<span class="pc bpc" id="L174" title="1 of 2 branches missed.">      if (!jwk.verify(jwa, payloadInput, signingInput)) {</span>
<span class="nc" id="L175">        throw new IllegalArgumentException(&quot;Signature verification failed&quot;);</span>
      }
<span class="fc" id="L177">    } catch (Throwable ex) {</span>
<span class="fc" id="L178">      logger.warn(&quot;Signature verification failed: &quot;, ex);</span>
<span class="fc" id="L179">      throw new IllegalArgumentException(&quot;Signature verification failed&quot;, ex);</span>
<span class="fc" id="L180">    }</span>
<span class="fc" id="L181">  }</span>

  private void validateSub(JWT jwt) throws IllegalArgumentException {
<span class="fc bfc" id="L184" title="All 2 branches covered.">    if (Strings.isNullOrEmpty(jwt.getSubject())) {</span>
<span class="fc" id="L185">      throw new IllegalArgumentException(&quot;No subject specified in token&quot;);</span>
    }
<span class="fc" id="L187">  }</span>

  private void validateAud(JWT jwt, List&lt;String&gt; requiredAudList, boolean ignoreRequiredAud) throws IllegalArgumentException {
<span class="pc bpc" id="L190" title="2 of 6 branches missed.">    if ((requiredAudList == null) || (!ignoreRequiredAud &amp;&amp; requiredAudList.isEmpty())) {</span>
<span class="fc" id="L191">      throw new IllegalStateException(&quot;Required audience not set&quot;);</span>
    }
<span class="pc bpc" id="L193" title="1 of 2 branches missed.">    if (jwt.getAudience() == null) {</span>
<span class="nc" id="L194">      throw new IllegalArgumentException(&quot;Token does not include aud claim&quot;);</span>
    }
<span class="fc bfc" id="L196" title="All 2 branches covered.">    for (String aud : jwt.getAudience()) {</span>
<span class="fc bfc" id="L197" title="All 2 branches covered.">      for (String requiredAud : requiredAudList) {</span>
<span class="fc bfc" id="L198" title="All 2 branches covered.">        if (requiredAud.equals(aud)) {</span>
<span class="fc" id="L199">          return;</span>
        }
<span class="fc" id="L201">      }</span>
<span class="fc" id="L202">    }</span>
<span class="pc bpc" id="L203" title="1 of 2 branches missed.">    if (!ignoreRequiredAud) {</span>
<span class="pc bpc" id="L204" title="1 of 2 branches missed.">      if (requiredAudList.size() == 1) {</span>
<span class="fc" id="L205">        logger.warn(&quot;Required audience ({}) not found in token aud claim: {}&quot;, requiredAudList.get(0), jwt.getAudience());</span>
      } else {
<span class="nc" id="L207">        logger.warn(&quot;None of the required audiences ({}) found in token aud claim: {}&quot;, requiredAudList, jwt.getAudience());</span>
      }
<span class="fc" id="L209">      throw new IllegalArgumentException(&quot;Required audience not found in token&quot;);</span>
    }
<span class="nc" id="L211">  }</span>

  private void validateExp(JWT jwt, long nowSeconds) throws IllegalArgumentException {
<span class="fc bfc" id="L214" title="All 2 branches covered.">    if (jwt.getExpiration() != null) {</span>
<span class="fc" id="L215">      long target = nowSeconds - timeLeewaySeconds;</span>
<span class="fc bfc" id="L216" title="All 2 branches covered.">      if (jwt.getExpiration() &lt; target) {</span>
<span class="fc" id="L217">        logger.warn(&quot;Token exp = {} ({}), now = {} ({}), target = {} ({})&quot;, jwt.getExpiration(), jwt.getExpirationLocalDateTime(), nowSeconds, LocalDateTime.ofEpochSecond(nowSeconds, 0, ZoneOffset.UTC), target, LocalDateTime.ofEpochSecond(target, 0, ZoneOffset.UTC));</span>
<span class="fc" id="L218">        throw new IllegalArgumentException(&quot;Token is not valid after &quot; + jwt.getExpirationLocalDateTime());</span>
      }
<span class="pc bpc" id="L220" title="1 of 2 branches missed.">    } else if (requireExp) {</span>
<span class="fc" id="L221">      throw new IllegalArgumentException(&quot;Token does not specify exp&quot;);</span>
    }
<span class="fc" id="L223">  }</span>

  private void validateNbf(JWT jwt, long nowSeconds) throws IllegalArgumentException {
<span class="fc bfc" id="L226" title="All 2 branches covered.">    if (jwt.getNotBefore() != null) {</span>
<span class="fc" id="L227">      long target = nowSeconds + timeLeewaySeconds;</span>
<span class="fc bfc" id="L228" title="All 2 branches covered.">      if (jwt.getNotBefore() &gt; target) {</span>
<span class="fc" id="L229">        throw new IllegalArgumentException(&quot;Token is not valid until &quot; + jwt.getNotBeforeLocalDateTime());</span>
      }
<span class="fc bfc" id="L231" title="All 2 branches covered.">    } else if (requireNbf) {</span>
<span class="fc" id="L232">      throw new IllegalArgumentException(&quot;Token does not specify exp&quot;);</span>
    }
<span class="fc" id="L234">  }</span>

  private JsonWebAlgorithm validateAlgorithm(String algorithm) {
<span class="pc bpc" id="L237" title="1 of 2 branches missed.">    if (algorithm == null) {</span>
<span class="nc" id="L238">      logger.warn(&quot;No signature algorithm in token.&quot;);</span>
<span class="nc" id="L239">      throw new IllegalArgumentException(&quot;Parse of signed JWT failed&quot;);</span>
    }
    JsonWebAlgorithm jwa;
    try {
<span class="fc" id="L243">      jwa = JsonWebAlgorithm.valueOf(algorithm);</span>
<span class="nc" id="L244">    } catch (Throwable ex) {</span>
<span class="nc" id="L245">      logger.warn(&quot;Failed to parse algorithm \&quot;{}\&quot;&quot;, algorithm);</span>
<span class="nc" id="L246">      throw new IllegalArgumentException(&quot;Parse of signed JWT failed&quot;);</span>
<span class="fc" id="L247">    }</span>
<span class="fc bfc" id="L248" title="All 2 branches covered.">    if (!permittedAlgs.contains(jwa)) {</span>
<span class="fc" id="L249">      logger.warn(&quot;Failed to find algorithm \&quot;{}\&quot; in {}&quot;, algorithm, permittedAlgs);</span>
<span class="fc" id="L250">      throw new IllegalArgumentException(&quot;Parse of signed JWT failed&quot;);</span>
    }
<span class="fc" id="L252">    return jwa;</span>
  }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.9.202303310957</span></div></body></html>