<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>JWK.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JWT Validator - Vertx</a> &gt; <a href="index.source.html" class="el_package">uk.co.spudsoft.jwtvalidatorvertx</a> &gt; <span class="el_source">JWK.java</span></div><h1>JWK.java</h1><pre class="source lang-java linenums">/*
 * Copyright (C) 2022 jtalbut
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
 */
package uk.co.spudsoft.jwtvalidatorvertx;

import com.google.common.primitives.Bytes;
import io.vertx.core.json.JsonObject;
import java.math.BigInteger;
import java.security.AlgorithmParameters;
import java.security.InvalidKeyException;
import java.security.Key;
import java.security.KeyFactory;
import java.security.NoSuchAlgorithmException;
import java.security.PublicKey;
import java.security.Signature;
import java.security.SignatureException;
import java.security.spec.ECGenParameterSpec;
import java.security.spec.ECParameterSpec;
import java.security.spec.ECPoint;
import java.security.spec.ECPublicKeySpec;
import java.security.spec.InvalidKeySpecException;
import java.security.spec.InvalidParameterSpecException;
import java.security.spec.RSAPublicKeySpec;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.security.InvalidAlgorithmParameterException;
import java.security.spec.EdECPoint;
import java.security.spec.EdECPublicKeySpec;
import java.security.spec.NamedParameterSpec;
import java.util.Base64;

/**
 * Represent a single Json Web Key as defined in RFC 7517.
 * https://datatracker.ietf.org/doc/html/rfc7517
 * 
 * @author jtalbut
 */
public class JWK {
  
<span class="fc" id="L54">  private static final Logger logger = LoggerFactory.getLogger(JWK.class);</span>
  
  private final long expiryMs;
  
  private final String kid;
  private final String use;
  private final String kty;
  private final Key key;

  /**
   * Constructor.
   * 
   * @param expiryMs The time in ms from the epoch (i.e. to be compared with System.currentTimeMillis) at which this data should be discarded.
   *    Should be found by parsing cache-control headers.
   * @param jo The JsonObject that contains the JWK as defined in RFC7517.
   * @throws java.security.NoSuchAlgorithmException if the algorithm in the JWK is not known.
   * @throws java.security.spec.InvalidKeySpecException if the key specification in the JWK is inappropriate for the key factory to produce a key.
   * @throws java.security.spec.InvalidParameterSpecException  if there is a bug in the JWK code.
   */
<span class="fc" id="L73">  public JWK(long expiryMs, JsonObject jo) throws NoSuchAlgorithmException, InvalidKeySpecException, InvalidParameterSpecException {</span>
<span class="fc" id="L74">    this.expiryMs = expiryMs;</span>
    
<span class="fc" id="L76">    this.kid = jo.getString(&quot;kid&quot;);</span>
<span class="fc" id="L77">    this.use = jo.getString(&quot;use&quot;);</span>
<span class="fc" id="L78">    this.kty = jo.getString(&quot;kty&quot;);</span>
    
<span class="fc bfc" id="L80" title="All 2 branches covered.">    if (!hasValue(kid)) {</span>
<span class="fc" id="L81">      throw new IllegalArgumentException(&quot;Key ID (kid) not specified in JWK&quot;);</span>
    }
    
<span class="fc bfc" id="L84" title="All 2 branches covered.">    if (!hasValue(kty)) {</span>
<span class="fc" id="L85">      throw new IllegalArgumentException(&quot;Key type (kty) not specified in JWK&quot;);</span>
    } else {
<span class="pc bpc" id="L87" title="1 of 4 branches missed.">      switch (kty) {</span>
        case &quot;RSA&quot;:
        case &quot;RSASSA&quot;:
<span class="fc" id="L90">          validateAlg(jo, &quot;RSA&quot;);</span>
<span class="fc" id="L91">          key = createRSA(jo);</span>
<span class="fc" id="L92">          break;</span>
        case &quot;EC&quot;:
<span class="fc" id="L94">          validateAlg(jo, &quot;ECDSA&quot;);</span>
<span class="fc" id="L95">          key = createEC(jo);</span>
<span class="fc" id="L96">          break;</span>
        case &quot;OKP&quot;:
<span class="fc" id="L98">          validateAlg(jo, &quot;EdDSA&quot;);</span>
<span class="fc" id="L99">          key = createOKP(jo);</span>
<span class="fc" id="L100">          break;</span>
        default:
<span class="nc" id="L102">          throw new IllegalArgumentException(&quot;Unsupported key type: &quot; + kty);</span>
      }
    }
<span class="fc" id="L105">  }</span>
  
  private void validateAlg(JsonObject jo, String requiredFamily) {
    // From RFC 7515 alg is optional and I haven't ever seen it in the wild.
    // If it is provided we just validate that it is compatible with the kty.
<span class="fc" id="L110">    String algString = jo.getString(&quot;alg&quot;);</span>
<span class="fc bfc" id="L111" title="All 2 branches covered.">    if (algString != null) {</span>
<span class="fc" id="L112">      JsonWebAlgorithm alg = JsonWebAlgorithm.valueOf(algString);</span>
<span class="fc bfc" id="L113" title="All 2 branches covered.">      if (!requiredFamily.equals(alg.getFamilyName())) {</span>
<span class="fc" id="L114">        logger.warn(&quot;Algorithm ({}) does not match key type ({})&quot;, algString, kty);</span>
<span class="fc" id="L115">        throw new IllegalArgumentException(&quot;Algorithm (&quot; + algString + &quot;) does not match key type (&quot; + kty + &quot;)&quot;);</span>
      }
    }
<span class="fc" id="L118">  }</span>

  /**
   * Get the expiry time in ms from the epoch.
   * @return the expiry time in ms from the epoch.
   */
  public long getExpiryMs() {
<span class="fc" id="L125">    return expiryMs;</span>
  }

  /**
   * Get the key identifier.
   * &lt;a href=&quot;https://datatracker.ietf.org/doc/html/rfc7517#section-4.5&quot;&gt;https://datatracker.ietf.org/doc/html/rfc7517#section-4.5&lt;/a&gt;
   * @return the key identifier.
   */
  public String getKid() {
<span class="fc" id="L134">    return kid;</span>
  }

  /**
   * Get the key use string.
   * &lt;a href=&quot;https://datatracker.ietf.org/doc/html/rfc7517#section-4.2&quot;&gt;https://datatracker.ietf.org/doc/html/rfc7517#section-4.2&lt;/a&gt;
   * This should be &quot;sig&quot; for all known uses, but its presence is optional, so it's ignored.
   * @return the key use string.
   */
  public String getUse() {
<span class="fc" id="L144">    return use;</span>
  }

  /**
   * Get the key represented by this JWK.
   * @return the key represented by this JWK.
   */
  public Key getKey() {
<span class="fc" id="L152">    return key;</span>
  }
  
  /**
   * Verify a signature using the key in this JWK.
   * 
   * @param algorithm The algorithm specified in the token, which may not be the same as the JWK algorithm (RSA-PSS).
   * @param signature The signature that has been provided for the JWT.
   * @param data The data to be verified.
   * @return True if the signature can only have been created using this key and the data provided.
   * 
   * @throws InvalidKeyException if the key is not appropriate for the signer.
   * @throws NoSuchAlgorithmException if the algorithm is not known to the JDK security subsystem,.
   * @throws SignatureException if the signature is invalid
   * @throws InvalidAlgorithmParameterException if the algorithm is configured with incorrect parameters.
   */
  public boolean verify(JsonWebAlgorithm algorithm, byte[] signature, byte[] data) throws InvalidKeyException, NoSuchAlgorithmException, SignatureException, InvalidAlgorithmParameterException {
<span class="fc" id="L169">    Signature signer = Signature.getInstance(algorithm.getJdkAlgName());</span>
<span class="fc bfc" id="L170" title="All 2 branches covered.">    if (algorithm.getParameter() != null) {</span>
<span class="fc" id="L171">      signer.setParameter(algorithm.getParameter());</span>
    }
<span class="fc" id="L173">    signer.initVerify((PublicKey) key);</span>
<span class="fc" id="L174">    signer.update(data);</span>
<span class="fc" id="L175">    return signer.verify(signature);</span>
  }
  
  private static boolean hasValue(String s) {
<span class="pc bpc" id="L179" title="1 of 4 branches missed.">    return s != null &amp;&amp; !s.isBlank();</span>
  }

  private static Key createRSA(JsonObject json) throws NoSuchAlgorithmException, InvalidKeySpecException {
<span class="fc" id="L183">    String nStr = json.getString(&quot;n&quot;);</span>
<span class="fc" id="L184">    String eStr = json.getString(&quot;e&quot;);</span>
<span class="fc bfc" id="L185" title="All 4 branches covered.">    if (hasValue(nStr) &amp;&amp; hasValue(eStr)) {</span>
<span class="fc" id="L186">      final BigInteger n = new BigInteger(1, Base64.getUrlDecoder().decode(nStr));</span>
<span class="fc" id="L187">      final BigInteger e = new BigInteger(1, Base64.getUrlDecoder().decode(eStr));</span>
<span class="fc" id="L188">      return KeyFactory.getInstance(&quot;RSA&quot;).generatePublic(new RSAPublicKeySpec(n, e));</span>
    }
<span class="fc" id="L190">    throw new IllegalArgumentException(&quot;JWK (&quot; + json + &quot;) does not contain valid RSA public key&quot;);</span>
  }
  
  private static String getJdkEcCurveName(String curve) {
<span class="fc bfc" id="L194" title="All 2 branches covered.">   if (!hasValue(curve)) {</span>
<span class="fc" id="L195">      throw new IllegalArgumentException(&quot;JWK does not contain valid EC public key (curve not specified)&quot;);</span>
    }
<span class="pc bpc" id="L197" title="1 of 4 branches missed.">    switch (curve) {</span>
      case &quot;P-256&quot;:
<span class="fc" id="L199">        return &quot;secp256r1&quot;;</span>
      case &quot;P-384&quot;:
<span class="fc" id="L201">        return &quot;secp384r1&quot;;</span>
      case &quot;P-521&quot;:
<span class="fc" id="L203">        return &quot;secp521r1&quot;;</span>
      default:
<span class="nc" id="L205">        return curve;</span>
    }
  }
  
  private static Key createEC(JsonObject json) throws NoSuchAlgorithmException, InvalidKeySpecException, InvalidParameterSpecException {
<span class="fc" id="L210">    AlgorithmParameters parameters = AlgorithmParameters.getInstance(&quot;EC&quot;);</span>
    
<span class="fc" id="L212">    String curve = getJdkEcCurveName(json.getString(&quot;crv&quot;));</span>
<span class="fc" id="L213">    parameters.init(new ECGenParameterSpec(curve));</span>

<span class="fc" id="L215">    String xStr = json.getString(&quot;x&quot;);</span>
<span class="fc" id="L216">    String yStr = json.getString(&quot;y&quot;);</span>
<span class="fc bfc" id="L217" title="All 4 branches covered.">    if (hasValue(xStr) &amp;&amp; hasValue(yStr)) {</span>
<span class="fc" id="L218">      final BigInteger x = new BigInteger(1, Base64.getUrlDecoder().decode(xStr));</span>
<span class="fc" id="L219">      final BigInteger y = new BigInteger(1, Base64.getUrlDecoder().decode(yStr));</span>
<span class="fc" id="L220">      return KeyFactory.getInstance(&quot;EC&quot;).generatePublic(new ECPublicKeySpec(new ECPoint(x, y), parameters.getParameterSpec(ECParameterSpec.class)));</span>
    }
<span class="fc" id="L222">    throw new IllegalArgumentException(&quot;JWK (&quot; + json + &quot;) does not contain valid EC public key&quot;);</span>
  }
  
  private static EdECPoint byteArrayToEdPoint(byte[] arr) {
<span class="fc" id="L226">    byte msb = arr[arr.length - 1];</span>
<span class="fc bfc" id="L227" title="All 2 branches covered.">    boolean xOdd = (msb &amp; 0x80) != 0;</span>
<span class="fc" id="L228">    arr[arr.length - 1] &amp;= (byte) 0x7F;</span>
<span class="fc" id="L229">    Bytes.reverse(arr, 0, arr.length);</span>
<span class="fc" id="L230">    BigInteger y = new BigInteger(1, arr);</span>
<span class="fc" id="L231">    return new EdECPoint(xOdd, y);</span>
  }
  
  private static Key createOKP(JsonObject json) throws NoSuchAlgorithmException, InvalidKeySpecException {
<span class="fc" id="L235">    String xStr = json.getString(&quot;x&quot;);</span>
<span class="fc" id="L236">    String curve = json.getString(&quot;crv&quot;);</span>
    
<span class="fc bfc" id="L238" title="All 4 branches covered.">    if (hasValue(xStr) &amp;&amp; hasValue(curve)) {</span>
<span class="fc" id="L239">      KeyFactory kf = KeyFactory.getInstance(&quot;EdDSA&quot;);</span>
<span class="fc" id="L240">      NamedParameterSpec paramSpec = new NamedParameterSpec(curve);</span>
<span class="fc" id="L241">      EdECPublicKeySpec pubSpec = new EdECPublicKeySpec(paramSpec, byteArrayToEdPoint(Base64.getUrlDecoder().decode(xStr)));</span>
<span class="fc" id="L242">      return kf.generatePublic(pubSpec);</span>
    }
<span class="fc" id="L244">    throw new IllegalArgumentException(&quot;JWK (&quot; + json + &quot;) does not contain valid OKP public key&quot;);</span>
  }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>