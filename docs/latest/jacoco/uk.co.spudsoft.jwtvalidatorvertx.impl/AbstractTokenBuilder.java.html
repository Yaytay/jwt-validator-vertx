<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>AbstractTokenBuilder.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JWT Validator - Vertx</a> &gt; <a href="index.source.html" class="el_package">uk.co.spudsoft.jwtvalidatorvertx.impl</a> &gt; <span class="el_source">AbstractTokenBuilder.java</span></div><h1>AbstractTokenBuilder.java</h1><pre class="source lang-java linenums">/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package uk.co.spudsoft.jwtvalidatorvertx.impl;

import com.google.common.cache.Cache;
import io.vertx.core.json.JsonArray;
import io.vertx.core.json.JsonObject;
import java.nio.charset.StandardCharsets;
import java.security.SecureRandom;
import java.util.Arrays;
import java.util.Base64;
import java.util.Base64.Encoder;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import uk.co.spudsoft.jwtvalidatorvertx.AlgorithmAndKeyPair;
import uk.co.spudsoft.jwtvalidatorvertx.JsonWebAlgorithm;
import uk.co.spudsoft.jwtvalidatorvertx.TokenBuilder;




/**
 * Abstract implementation of TokenBuilder.
 * &lt;p&gt;
 * The actual creation of keys is left to a subclass to implement.
 * &lt;p&gt;
 * This class can perform all the work of a TokenBuilder implementation apart from the generation of keys, however most methods
 * are designed to be overrideable so that a specific implementation can do something different if that is useful.
 * @author jtalbut
 */
public abstract class AbstractTokenBuilder implements TokenBuilder {

  @SuppressWarnings(&quot;constantname&quot;)
<span class="fc" id="L40">  private static final Logger logger = LoggerFactory.getLogger(AbstractTokenBuilder.class);</span>

  /**
   * Base64 encoded that implementations may (should) use.
   */
<span class="fc" id="L45">  protected static final Encoder BASE64 = Base64.getUrlEncoder().withoutPadding();</span>
  /**
   * Secure random number generator that implementations may  use.
   */
<span class="fc" id="L49">  protected static final SecureRandom RANDOM = new SecureRandom();</span>
  
<span class="fc" id="L51">  private boolean headerNotValidBase64 = false;</span>
<span class="fc" id="L52">  private boolean payloadNotValidBase64 = false;</span>
<span class="fc" id="L53">  private boolean signatureNotValidBase64 = false;</span>
<span class="fc" id="L54">  private boolean headerNotJson = false;</span>
<span class="fc" id="L55">  private boolean payloadNotJson = false;</span>
<span class="fc" id="L56">  private boolean signatureNotValidHash = false;</span>
<span class="fc" id="L57">  private boolean kidInvalid = false;</span>
  
  /**
   * The key cache that is shared with the {@link uk.co.spudsoft.jwtvalidatorvertx.JwksHandler}.
   * &lt;p&gt;
   * Note that it is the TokenBuilder that is responsible for causing keys to be created and cached, the 
   * {@link uk.co.spudsoft.jwtvalidatorvertx.JwksHandler} just makes them available.
   */
  protected final Cache&lt;String, AlgorithmAndKeyPair&gt; keyCache;

  /**
   * Constructor.
   * 
   * @param keyCache The key cache that is shared with the {@link uk.co.spudsoft.jwtvalidatorvertx.JwksHandler}.
   */
<span class="fc" id="L72">  public AbstractTokenBuilder(Cache&lt;String, AlgorithmAndKeyPair&gt; keyCache) {</span>
<span class="fc" id="L73">    this.keyCache = keyCache;</span>
<span class="fc" id="L74">  }</span>

  @Override
  public TokenBuilder setHeaderNotValidBase64(boolean headerNotValidBase64) {
<span class="fc" id="L78">    this.headerNotValidBase64 = headerNotValidBase64;</span>
<span class="fc" id="L79">    return this;</span>
  }

  @Override
  public TokenBuilder setPayloadNotValidBase64(boolean payloadNotValidBase64) {
<span class="fc" id="L84">    this.payloadNotValidBase64 = payloadNotValidBase64;</span>
<span class="fc" id="L85">    return  this;</span>
  }

  @Override
  public TokenBuilder setSignatureNotValidBase64(boolean signatureNotValidBase64) {
<span class="fc" id="L90">    this.signatureNotValidBase64 = signatureNotValidBase64;</span>
<span class="fc" id="L91">    return this;</span>
  }

  @Override
  public TokenBuilder setHeaderNotJson(boolean headerNotJson) {
<span class="fc" id="L96">    this.headerNotJson = headerNotJson;</span>
<span class="fc" id="L97">    return this;</span>
  }

  @Override
  public TokenBuilder setPayloadNotJson(boolean payloadNotJson) {
<span class="fc" id="L102">    this.payloadNotJson = payloadNotJson;</span>
<span class="fc" id="L103">    return this;</span>
  }

  @Override
  public TokenBuilder setSignatureNotValidHash(boolean signatureNotValidHash) {
<span class="fc" id="L108">    this.signatureNotValidHash = signatureNotValidHash;</span>
<span class="fc" id="L109">    return this;</span>
  }
  
  @Override
  public TokenBuilder setKidInvalid(boolean kidInvalid) {
<span class="fc" id="L114">    this.kidInvalid = kidInvalid;</span>
<span class="fc" id="L115">    return this;</span>
  }
  
  @Override
  public String buildToken(JsonWebAlgorithm jwa,
           String kid,
           String iss,
           String sub,
           List&lt;String&gt; aud,
           Long nbf,
           Long exp,
           Map&lt;String, Object&gt; otherClaims
  ) throws Exception {

<span class="fc" id="L129">    JsonObject header = generateHeaderNode(kid, jwa);</span>
<span class="fc" id="L130">    logger.debug(&quot;header: {}&quot;, header);</span>

<span class="fc" id="L132">    JsonObject claims = generateClaimsNode(iss, sub, exp, nbf, aud, otherClaims);</span>
<span class="fc" id="L133">    logger.debug(&quot;claims: {}&quot;, claims);</span>

<span class="fc" id="L135">    String headerBase64 = base64Header(header);</span>

<span class="fc" id="L137">    String claimsBase64 = base64Claims(claims);</span>

    String signatureBase64;
    
<span class="fc bfc" id="L141" title="All 4 branches covered.">    if ((kid != null) &amp;&amp; (jwa != JsonWebAlgorithm.none)) {</span>
<span class="fc" id="L142">      byte[] signature = generateSignature(kid, jwa, headerBase64, claimsBase64);</span>
<span class="fc bfc" id="L143" title="All 2 branches covered.">      if (signatureNotValidHash) {</span>
<span class="fc" id="L144">        signature = Arrays.copyOf(signature, signature.length - 1);</span>
      }
<span class="fc" id="L146">      signatureBase64 = base64Signature(signature);</span>
<span class="fc" id="L147">    } else {</span>
<span class="fc" id="L148">      signatureBase64 = &quot;&quot;;</span>
    }

<span class="fc" id="L151">    String token = constructToken(headerBase64, claimsBase64, signatureBase64);</span>

<span class="fc" id="L153">    logger.debug(&quot;Result: {}&quot;, token);</span>

<span class="fc" id="L155">    return token;</span>
  }

  /**
   * Helper method to generate the token header node.
   * @param kid The key ID.
   * @param algorithm The algorithm.
   * @return The created JsonObject header node.
   */
  protected JsonObject generateHeaderNode(String kid, JsonWebAlgorithm algorithm) {
<span class="fc" id="L165">    JsonObject header = new JsonObject();</span>
<span class="fc" id="L166">    header.put(&quot;typ&quot;, &quot;JWT&quot;);</span>
<span class="fc bfc" id="L167" title="All 2 branches covered.">    if (kid != null) {</span>
<span class="fc bfc" id="L168" title="All 2 branches covered.">      if (kidInvalid) {</span>
<span class="fc" id="L169">        header.put(&quot;kid&quot;, &quot;INVALID&quot;);</span>
      } else {
<span class="fc" id="L171">        header.put(&quot;kid&quot;, kid);</span>
      }
    }
<span class="fc" id="L174">    header.put(&quot;alg&quot;, algorithm.getName());</span>
<span class="fc" id="L175">    return header;</span>
  }

  /**
   * Helper method to build the payload for a token.
   * @param iss The iss (issuer) claim.
   * @param sub The sub (subject) claim.
   * @param exp The exp (expiry) claim.
   * @param nbf The nbf (not before) claim.
   * @param aud The aud (audience) claim.
   * @param otherClaims Map of other claims that are to be added.
   * Any claims in otherClaims will override anything else added to the claims.
   * @return a JsonObject of the payload for a token.
   */
  protected JsonObject generateClaimsNode(
          String iss
          , String sub
          , Long exp
          , Long nbf
          , List&lt;String&gt; aud
          , Map&lt;String, Object&gt; otherClaims
  ) {
<span class="fc" id="L197">    JsonObject claims = new JsonObject();</span>
<span class="fc bfc" id="L198" title="All 2 branches covered.">    if (sub != null) {</span>
<span class="fc" id="L199">      claims.put(&quot;sub&quot;, sub);</span>
    }
<span class="fc bfc" id="L201" title="All 2 branches covered.">    if (iss != null) {</span>
<span class="fc" id="L202">      claims.put(&quot;iss&quot;, iss);</span>
    }
<span class="fc bfc" id="L204" title="All 2 branches covered.">    if (exp != null) {</span>
<span class="fc" id="L205">      claims.put(&quot;exp&quot;, exp);</span>
    }
<span class="fc bfc" id="L207" title="All 2 branches covered.">    if (nbf != null) {</span>
<span class="fc" id="L208">      claims.put(&quot;nbf&quot;, nbf);</span>
    }
<span class="fc bfc" id="L210" title="All 2 branches covered.">    if (aud != null) {</span>
<span class="pc bpc" id="L211" title="1 of 2 branches missed.">      if (aud.size() == 1) {</span>
<span class="fc" id="L212">        claims.put(&quot;aud&quot;, aud.get(0));</span>
      } else {
<span class="nc" id="L214">        JsonArray array = new JsonArray();</span>
<span class="nc" id="L215">        claims.put(&quot;aud&quot;, array);</span>
<span class="nc bnc" id="L216" title="All 2 branches missed.">        for (String member : aud) {</span>
<span class="nc" id="L217">          array.add(member);</span>
<span class="nc" id="L218">        }</span>
      }
    }
<span class="pc bpc" id="L221" title="1 of 2 branches missed.">    if (otherClaims != null) {</span>
<span class="fc bfc" id="L222" title="All 2 branches covered.">      for (Entry&lt;String, Object&gt; claim : otherClaims.entrySet()) {</span>
<span class="fc" id="L223">        claims.put(claim.getKey(), claim.getValue());</span>
<span class="fc" id="L224">      }</span>
    }
<span class="fc" id="L226">    return claims;</span>
  }

  /**
   * Helper method to convert a JsonObject into a base64 representation.
   * Optionally provides two ways in which the result can be invalidated.
   * @param notJson If the JSON should be broken before the base64 encoding.
   * @param brokenBase64 The the base64 encoding should be broken.
   * @param json The JSON to be encoded.
   * @return The JSON encoded as base64 (possibly broken).
   */
  protected String base64JSon(boolean notJson, boolean brokenBase64, JsonObject json) {
<span class="fc" id="L238">    String jsonString = json.toString();</span>
<span class="fc bfc" id="L239" title="All 2 branches covered.">    if (notJson) {</span>
<span class="fc" id="L240">      jsonString = jsonString.replaceAll(&quot;\&quot;&quot;, &quot;&quot;);</span>
    }
<span class="fc" id="L242">    String base64 = BASE64.encodeToString(jsonString.getBytes(StandardCharsets.UTF_8));</span>
<span class="fc bfc" id="L243" title="All 2 branches covered.">    if (brokenBase64) {</span>
<span class="fc" id="L244">      base64 = base64.substring(0, base64.length() - 1);</span>
    }
<span class="fc" id="L246">    return base64;</span>
  }

  /**
   * Helper method to convert the header to base64, possibly breaking it.
   * Uses the headerNotJson and headerNotValidBase64 fields to determine whether the result should be valid.
   * @param header The header to convert.
   * @return The JSON encoded as base64 (possibly broken).
   */
  protected String base64Header(JsonObject header) {
<span class="fc" id="L256">    return base64JSon(headerNotJson, headerNotValidBase64, header);</span>
  }

  /**
   * Helper method to convert the payload to base64, possibly breaking it.
   * Uses the payloadNotJson and payloadNotValidBase64 fields to determine whether the result should be valid.
   * @param claims The claims to convert.
   * @return The JSON encoded as base64 (possibly broken).
   */
  protected String base64Claims(JsonObject claims) {
<span class="fc" id="L266">    return base64JSon(payloadNotJson, payloadNotValidBase64, claims);</span>
  }

  /**
   * Sign the token header and claims using the specified key.
   * @param kid The key to use to sign the header and claims, if this key is not found in the cache it will be generated.
   * @param algorithm The algorithm to use to generate the key, if it is not found in the cache.
   * @param headerBase64 The header to include in the signature.
   * @param claimsBase64 The claims to include in the signature.
   * @return The signature of the header and claims.
   * @throws Exception If the security subsystem is unable to complete the operation.
   */
  protected abstract byte[] generateSignature(String kid, JsonWebAlgorithm algorithm, String headerBase64, String claimsBase64) throws Exception;

  /**
   * Helper method to base6t4 encode the signature, possibly breaking it.
   * Uses the signatureNotValidBase64 fields to determine whether the result should be valid.
   * @param signature The signature of the header and payload.
   * @return The base64 encoded signature.
   */
  protected String base64Signature(byte[] signature) {
<span class="fc" id="L287">    String signatureBase64 = BASE64.encodeToString(signature);</span>
<span class="fc bfc" id="L288" title="All 2 branches covered.">    if (signatureNotValidBase64) {</span>
<span class="fc" id="L289">      signatureBase64 = signatureBase64.substring(0, signatureBase64.length() - 1);</span>
    }
<span class="fc" id="L291">    return signatureBase64;</span>
  }

  /**
   * Helper method to concatenate the three parts of the token.
   * @param headerBase64 The header, base 64 encoded.
   * @param claimsBase64 The claims, base 64 encoded.
   * @param signatureBase64 The signature, base 64 encoded.
   * @return The final JWS.
   */
  protected String constructToken(String headerBase64, String claimsBase64, String signatureBase64) {
<span class="fc" id="L302">    String token = headerBase64 + &quot;.&quot; + claimsBase64 + &quot;.&quot; + signatureBase64;</span>
<span class="fc" id="L303">    return token;</span>
  }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>